# Streamerio
配信者向けの 2D アクションゲームシステムです。配信者が Unity でゲームを操作し、視聴者が Web ページからボタンを押してゲーム内でアイテム補助や敵による妨害などのイベントを発生させることができます。システムは Next.js（フロントエンド）、Go（バックエンド）、Unity（ゲーム）で構成され、リアルタイムな相互作用を提供します。

## ドキュメント

- [開発ログ](docs/dev-log.md) - 実装履歴と設計判断の記録
- [デプロイ環境変数設定](docs/deployment-env-vars.md) - Cloud Run デプロイ時の環境変数設定手順
- [ゲーム終了処理計画](docs/game_end_plan.md) - ゲーム終了時の処理フロー

## サーバー構成
- [処理フロー](docs/flow.md) - 配信者サイドと視聴者側の処理フロー
DBはpostgreSQLをsupabaseを使用、またインメモリDBとしてRedisをUpstashで使用、またPub/SubとしてRedisを使用
サーバーはHTTPサーバとWebSocketサーバで2つあり、両者ともにCloud Runにデプロイ
WebフロントサーバはNextでできたアプリをVercelにデプロイ
UnityはUnityroomにデプロイ


## 遊び方
- 配信者
    - ゲームを開始する
    - 移動、ジャンプ、攻撃が可能
    - HPが0になる、制限時間を超えることでゲームオーバー
    - ステージの最後まで走ることでゲームクリア
- 視聴者
    - 動画視聴用デバイスともう一つゲーム参加用のデバイスを準備
    - QRコードや視聴者参加用URLからゲームに参加
    - 魔法ボタンを押すことで配信者を守ることができる
    - 敵ボタンを押すことで配信者を攻撃することができる
    - もっとも多くボタンを押した視聴者はリザルト画面で名前が表示される

## こだわり
- 企画
    - **視聴者参加型の新規性**: 単なるコメント連携ではなく、視聴者がゲーム内の「敵」や「味方」として直接干渉できるリアルタイムインタラクションを実現。
    - **公平なイベント集計**: 閾値を超えたボタン連打数も切り捨てずに次回分として持ち越す「超過分保持機能」を実装し、視聴者の熱量を無駄にしない公平なゲーム体験を提供。
- インゲーム (Unity)
    - **疎結合なアーキテクチャ**: `VContainer` を採用し、DI（依存性注入）によって `CameraManager` や `SkillSpawner` などの各コンポーネントを疎結合に管理。テスト容易性と保守性を向上。
    - **環境設定の外部化**: URL設定などを `ScriptableObject` (`ApiConfigSO`) に切り出し、開発/ステージング/本番環境の切り替えをインスペクタ上で安全かつ容易に行える運用フローを構築。
    - **リアルタイムフィードバック**: 視聴者のアクション（スキル発動・敵召喚）を `WebSocketManager` 経由で即座に受け取り、遅延を感じさせないゲームプレイを実現。
- アウトゲーム
    - **シームレスな参加フロー**: ゲーム開始時に発行されるQRコードを読み取るだけで、ログイン不要で即座に参加可能なUX設計。
    - **貢献度の可視化**: ゲーム終了時に `GameSessionService` が集計した詳細なリザルト（スキル使用回数、敵召喚回数、MVP視聴者）を即座に表示。
- WEBフロント (Next.js)
    - **イベントバッファリング**: `useBufferedButtonEvents` フックにより、視聴者の連打による大量のリクエストを一定間隔（1.5秒）でバッファリングし、サーバー負荷を軽減しつつリアルタイム性を維持。
    - **楽観的UI更新**: 通信待ちの間もUIを即座に反応させることで、視聴者にストレスのない操作感を提供。
    - **モダンな技術選定**: Next.js App Router と Server Actions を採用し、型安全性とパフォーマンスを両立。Tailwind CSS によるレスポンシブデザインでモバイル端末に最適化。
- WEBサーバー (Go)
    - **マイクロサービスライクな構成**: REST APIサーバーとUnity向けWebSocketサーバーを別プロセス (`cmd/server` vs `cmd/unityws`) に分離し、特性の異なる負荷に対して独立してスケール可能な構成を実現。
    - **堅牢なWebSocket設計**: `NativeWebSocket` と連携し、切断時の自動再接続やハートビート監視（Ping/Pong）を実装。再接続時には `room_id` を維持してスムーズに復帰できるロジックを実装。
    - **Clean Architecture**: Handler, Service, Repository 層を明確に分離し、ビジネスロジック（`GameSessionService`）とインフラストラクチャ（DB/WebSocket）の依存関係を整理。
    - **スケーラビリティ**: Redis Pub/Sub を導入し、複数サーバー構成でもイベントを全クライアントに正確に配信できる設計。

## がんばったこと
- インゲーム
    - **ネットワーク同期の調整**: WebSocketからのイベント受信 (`MessageType.game_event`) をトリガーに、メインスレッドで安全にオブジェクトを生成・操作するための排他制御とキューイングの実装。
    - **操作感の追求**: 視聴者の介入によるカオスな状況でも、プレイヤーがストレスなく操作できるよう、キャラクターの挙動（移動、ジャンプ、攻撃）を細かくチューニング。
- アウトゲーム
    - **状態管理の複雑さ解消**: シーン遷移（タイトル→インゲーム→リザルト）におけるデータの受け渡しを、シングルトンのマネージャークラスではなく、DIコンテナのスコープ機能 (`LifetimeScope`) を活用してきれいに解決。
- WEBフロント
    - **連打対策とUXの両立**: 視聴者が熱狂してボタンを連打してもサーバーがダウンしないよう、フロントエンド側でイベントを間引きつつ、ユーザーには連打の手応えを感じさせる演出の実装。
    - **オンボーディング**: 初めての視聴者でも直感的に遊べるよう、オーバーレイによる丁寧なチュートリアル（`OnboardingModal`）を実装。匿名での荒らし防止も兼ねて、名前入力フローを自然に組み込んだ。
- WEBサーバー
    - **ログ基盤の構築**: Cloudflare Workers を活用した中継ログシステムを構築。クライアント（Unity/Web）から直接 Google Cloud Logging に書き込むのではなく、Workers を経由させることで認証鍵の漏洩リスクを排除しつつ、詳細なクライアントログを収集可能にした。
    - **パフォーマンスチューニング**: 大量のイベント挿入に対して `Prepared Statement` をキャッシュして使い回すバッチ処理を実装し、DB負荷を大幅に低減。
    - **ID管理**: `ULID` を採用することで、分散環境でもユニークかつ時系列順にソート可能なIDを生成し、ログ追跡やデバッグを容易に。

## 失敗したこと/学んだこと
- インゲーム
    - **難易度調整の壁**: 視聴者数によって難易度が激変するため、動的なバランス調整（Dynamic Difficulty Adjustment）の導入が必要だった。現在は固定パラメータのため、参加者が多すぎるとクリア困難になる場合がある。
- アウトゲーム
    - **シーン遷移の設計**: 初期設計でシーン間の依存関係を考慮しきれておらず、後からデータの受け渡しロジックを追加する際に苦労した。最初からステートマシン (`IState`) を導入すべきだった。
- WEBフロント
    - **リアルタイム描画の負荷**: 視聴者数やイベント数が増えると再レンダリング回数が増加し、一部の低スペック端末で動作が重くなる現象が発生。`React.memo` や `useCallback` の徹底に加え、Canvas描画の導入も検討すべきだった。
- WEBサーバー
    - **インフラ制約への対応**: 当初 Cloudflare Queues を利用したログバッファリングを設計したが、無料プランの制約で使用できないことが判明。急遽 R2 を用いた Dead Letter Queue (DLQ) 方式に切り替えるなど、プラットフォームの制約を早期に検証することの重要性を学んだ。
    - **DB接続の枯渇**: 負荷テスト時にPostgreSQLのコネクションプールが枯渇する問題が発生。コネクション数の制限とタイムアウト設定 (`_connectionTimeout`) のチューニングを行い、リソース管理の重要性を痛感した。
